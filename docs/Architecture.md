# Architecture

이 문서에서는 our-map-server 프로젝트의 구조, 설계와 이러한 결정을 한 이유에 대해 다룬다.

## 대원칙

설계의 방향성은 다음과 같다.

* 계층 아키텍처를 도입하여 결합을 최소화할 수 있도록 프로젝트 구조를 잡는다.
* 프로젝트 전반에 걸쳐 컨벤션을 강하게 유지하여 코드의 위치와 동작을 예측 가능하게 만들고, 코드를 작성할 때 불필요한 고민을 하지 않고 컨벤션을 따르기만 하면 되도록 한다.
* 필요한 코드에만 의존할 수 있게 하고, 몰라도 되는 코드에는 의존할 수 없게 최대한 강제한다.
* 관련 없는 코드는 최대한 떨어뜨려놓는다. 다만, 불필요한 패키징으로 인해 boilerplate code가 너무 많이 증가하거나 code navigation이 힘들어지지 않아야 한다.
* 쉽게 테스트를 짤 수 있도록 한다.

## gradle projects

이 프로젝트는 [gradle의 multi project](https://docs.gradle.org/current/userguide/multi_project_builds.html) 구조를 채용하고 있다. 주요한 subproject에는 다음과 같은 3가지가 있다.

* database-migrator - DB 마이그레이션을 위한 스크립트를 모아놓은 프로젝트
* our-map - 계단정복지도의 도메인 로직 / 어플리케이션 로직을 모아놓은 프로젝트
* our-map-server - 계단정복지도 서버의 API 프로토콜과 구현을 모아놓은 프로젝트

가장 핵심 프로젝트인 our-map으로부터 각 프로젝트를 분리한 이유는 다음과 같다.

* database-migrator - 이 프로젝트를 분리한 이유는 순수히 기술적인 이유인데, database-migrator 코드와 리소스를 our-map 프로젝트에 넣으면 빌드 과정에서 `dbchangelog.xml` 파일이 중복으로 검색되어 테스트가 돌아가지 않는 문제가 발생한다(하나는 build/libs/our-map.jar 파일 안에서 발견되고, 다른 하나는 build/resources/main 폴더 안에서 발견됨). 이 문제를 해결하기 위해 liquibase 실행을 위한 프로젝트를 별도로 분리했다.
* our-map-server - protobuf 파일로부터 생성된 java DTO 파일들을 도메인 계층과 어플리케이션 계층이 참조할 수 없게 강제하고 싶었다. 이를 위해 protobuf 파일과 DTO conversion을 처리하는 코드를 모아 our-map으로부터 분리해냈다.

## our-map 구조

our-map 프로젝트는 최상단에서 봤을 때 아래와 같은 패키지 구조를 가진다.

* domain - 도메인 계층 관련 코드
* application - 어플리케이션 계층 관련 코드
* infra - 도메인과 어플리케이션 계층을 지원하기 위한 코드
  * persistence - 인프라 중 DB에 데이터를 저장하기 위한 코드
  * properties - 환경마다 달라질 수 있는 properties를 처리하기 위한 코드
* util - 프로젝트 전체에서 사용될 수 있는 유틸리티 코드

### 도메인 계층 구조

각 도메인 패키지 내부는 아래와 같이 구성된다.

* entity - DB에 저장되는 엔티티를 모아놓은 패키지.
* service - 서비스 로직을 모아놓은 패키지.
* repository - 레포지토리 인터페이스를 모아놓은 패키지.

여기서 몇 가지 설계 결정이 있다.

* 각 도메인 패키지마다 각각의 koin module을 노출한다 - 이는 테스트를 실행할 때 최소한의 모듈에 의존하는 테스트를 작성하기 위함이다.
* 엔티티에는 로직을 넣지 않고 서비스에 로직을 넣는다 - 이는 1. 엔티티에서 레포지토리를 얻어올 수 없어서 자신의 상태를 자신이 변경하게 만들기 어렵고, 2. CRUD 동작을 엔티티에 넣기 어렵다고 생각했기 때문이다.

### 어플리케이션 계층 구조

어플리케이션 계층은 아래와 같이 패키지를 구성한다.

* 도메인 계층의 각 도메인 별로 패키지를 파고, 각 도메인 패키지별로 koin module을 노출한다 - 이는 테스트를 실행할 때 최소한의 모듈에 의존하는 테스트를 작성하기 위함이다.
* 각 도메인 패키지 내부에서는 해당 패키지의 루트에 모든 코드를 배치한다 - 도메인 계층만큼 코드가 많지 않아서 각 도메인 내부에서는 별도의 패키지 hierarchy를 둘 필요가 없다고 판단했다.

## 코드 작성 시 원칙

* 재사용 가능한 비즈니스 로직(엔티티 상태 변경)은 도메인 계층에 구현하고, 트랜잭션 경계 설정은 어플리케이션 계층에 구현한다.
* 도메인 계층의 메소드는 인자로 엔티티 아이디 대신 엔티티 그 자체를 받는다. 엔티티 아이디를 통해 엔티티를 가져오는 것은 어플리케이션 계층에 구현한다.
* 프레젠테이션 계층은 되도록이면 어플리케이션 계층에만 의존하고, 도메인 계층에는 의존하지 않는다. 다만, DTO conversion 단계에서는 도메인 계층에 의존할 수 있다.
  * DTO conversion 단계에서 도메인 계층에 의존하는 것을 허용하는 이유는, 몇몇 정보는 엔티티에 캐시되어 있지 않고 여러 엔티티를 조합해서 계산해야만 하기 때문이다. e.g. VillageService.getRank()
* 복잡한 로직 없이 쿼리로만 구현이 가능한 조회 로직의 경우 레포지토리에 구현하고 사용한다. 이는 조회 로직을 서비스에 두면 cyclic dependency가 발생할 위험이 커지기 때문이다.
* 어플리케이션 계층 -> 도메인 계층, 인프라 계층 -> 어플리케이션/도메인 계층의 의존성을 가지고, 그 반대 방향으로는 의존하지 않아야 한다.
  * 이를 컴파일러 차원에서 강제할 수 있는 방법을 아직 찾지 못한 관계로, 지금은 개발자가 코드를 작성할 때 반대 방향으로 의존하지 않도록 자발적으로 유의해야만 한다.
* 테스트는 도메인 계층과 프레젠테이션 계층에 대해서 작성한다.
